一个无序正负项 数组，eg:[3, -6, 123, -945, -231, 112] 找出其中的最大的连续子序列

我的解答

我的思路是,首先设定数组第一个值为最大值,之后遍历所有的子序列和,与当前的最大值作比较,并且使用变量 缓存当前最大子序列的数组,全部循环之后,返回最大子序列和对应的数组

let arr = [-2,1,-3,4,-1,2,1,-5,4] ;  //9
function getMaxChildrenSum(arr){
  let bigest = arr[0];
  let largestArr = [arr[0]];
  for(let i=0;i<arr.length;i++){
    for(let j = i;j<arr.length;j++){
      let {sum,newArr} = sumIndexArr(i,j+1,arr)
      if(sum>bigest){
        bigest = sum;
        largestArr = newArr
      }
    }
  }
  return largestArr
}
function sumIndexArr(index,num,arr){
  // if(num == 1) return arr[index];
  let sum = 0;
  let newArr = arr.slice(index,num)
  for(let i=0;i<newArr.length;i++){
    sum+=newArr[i]
  }
  console.log(sum)
  console.log(newArr)
  return {sum,newArr};
}
console.log(getMaxChildrenSum(arr))
王东讲解

首先 , 我们看一下题目

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

中文版 题目: 目: https://leetcode-cn.com/problems/maximum-subarray/description/ 英文版 英文版 题目: 目: https://leetcode.com/problems/maximum-subarray/description/

基础的算法 或者说数据逻辑问题, 可以让你更好的去解决 复杂业务逻辑的时候 如何更好的去管理和处理你的数据 在MVVM 或者说 MV* 的年代 有一个清楚对数据结合业务的逻辑能力. 你能更好的管理你的数据 和 数据与DOM之间的关系 , 就能写出更好 更易读 更好维护的代码

一个数组, 找到它最大的连续子序列. 我们已经理解了 最大子序列的概念

那么, 从最简单的理解, 用暴力查询的方式.

首先列出 所有的子序列 然后找出其中和最大的 即可

实现思路:

一个 记录当前最大值的变量 maxSum

一个 子序列开始和结束的游标 变量

一个当前子序列的和 的 暂存变量 我们称之为 currentSum 或者 tmpSum (下文中 使用 currentSum)

找到所有的 子序列 我们可以通过 两层循环的方式来解决

第一层循环 i 从 0 ~ length-1 第二层循环 j 从 i ~ length - 1

这样的循环里 就可以找到所有的子序列了

下一步 我们是要计算出所有子序列的和

最简单的办法 就是 第三层循环 从 i ~ j 累加求出和 然后求出来的每个和 和 maxSum 去比较 如果比maxSum 大 就替换

伪代码: maxSum = maxSum < currentSum ? currentSum : maxSum

三层循环结束后 maxSum 就是我们要 求的解

return maxSum 即可

这个算法的时间复杂度是 O(n^3)

这是最简单的 也最好理解的求解方式. 我们习惯称之为 模拟

就是说 把题目的描述过程 执意成 代码 并求解

OK 到这里 第一种算法 已经讲完了 大家理解么

在算法题的分类中 模拟的解法 一般都比较慢 但是最好理解 所以 我们也基本都把 模拟 这种方案 当做算法入门 或者说code 入门 的基础

之所以 称之为 时间复杂度是 O(n^3) 是因为他的循环层数 是3 层 而且每层都是跟n相关的一个次数 (其实严格来讲 可能不够n^ 我们不纠结)

我们只要知道这种算法 会很慢 就好了~

王东: 所以 我们来想一下 如何去简化解法

王东: 我们在第二层循环中. 我们已经知道 当前的 i/j 之前的方法是在第三层的循环中 计算 i ~ j 的和

王东: 现在 我们在第二层中 在进入第二层之前 我们重置一下 currentSum 第一次循环 是 i ~ i 当前我们就把 i 的值 记录到 currentSum 去跟 maxSum对比 然后 maxSum = maxSum < currentSum ? currentSum : maxSum 第二次循环 是 i ~ i+1 我们就把 当前的 i+1 累加到 currentSum 这时候的 currentSum 就是 i ~ i + 1的值, 再去跟 maxSum 去比 然后 maxSum = maxSum < currentSum ? currentSum : maxSum

以此类推

第二层的循环中 就可以 计算出 以当前 i 开头的子序列中 最大的子序列是多少

王东: 现在我们看回 到 第一层循环

i 的取值 是从 0 ~ length-1 那么 我们是不是 可以找到 i 从 0 ~ length-1 所有的子序列中合作大的

我们的两层循环 就可以解决刚才三层循环 要解决的问题

王东: 我们整理下 伪代码的思路

第一层 i (0 ~ length - 1) currentSum 清零 第二层 j (i ~ length - 1) currentSum 累加 maxSum = maxSum < currentSum ? currentSum : maxSum

return maxSum

王东: 现在 我们的解法 优化到了 O(n^2)

王东: 大家对现在的解法 有不理解的地方么?

2min 的提问时间 我会回答比较共性的问题 其他的问题 我们可以在课后互相讨论 和 解答

王东: OK 现在开始进入 究极体~

王东: 当然了 可能不是完美的究极体

王东: 我把我的思路分享给大家

王东: 我们先找一个 demo 的数组

[-2,1,-3,4,-1,2,1,-5,4]

王东: 首先 我们可以简单的简化一下 这个数组 把 相邻 的 同 正负的数字 合起来 (为了方便讲=.= ) 因为同符号的连续数 一定会同时存在在 最大子序列里

比如 [-1 -2 -3 1 2 13 ]

那跟 [-6 16] 是没有去别的

王东: [-2,1,-3,4,-1,2,1,-5,4]

==>

[-2, 1, -3, 4, -1. 3, -5, 4]

王东: 然后 我们从头开始看

王东: -2 这是第一个元素

那么 我们认为 当前的 最大子序列和 就是 -2

王东: 然后 发现了 一个 正数 1 那我 我们可以确定 -2 一定不包含在 我们的最大子序列中

也就是说 数组开头 如果是负数 可以忽略过去

王东: 现在 我们的 数组 变成了

1, -3, 4, -1. 3, -5, 4

王东: 同理 结尾的如果是负数 也不需要考虑

王东: 现在 我们的 数组 变成了

1, -3, 4, -1. 3, -5, 4

我们继续

王东: 现在 第一个元素是 1 最大和 是 1

杨蜀黍:

我欲成风:

王东: 然后 下一个数 是 -3

那么 -3 对 1 这个数 起到了阻断作用 也就是说 -3 把 前边所有正数 积累的能量都磨平了 甚至还变成了一个负数 那么 -3 我们称之为 一个阻断

当前的 最大和 还是 1

王东: 现在 我们到了 4

那么现在的最大值 就是 4

王东: 我们继续向下看

下个数字是 -1 之前最大的和是 4

加起来之后是 3 影响并不大

我们继续带着他 向后看

王东: 下一个 是个正数 3

也就是 4 -1 3 这样的情况

我们是不是可以认为 这个-1 虽然 降低了 和 但是 他连接了左右的正数 让我们当前的最大值 变成了 6 更新最大值 继续看

王东: 下一个是 -5

同理 之前的 6 + -5 和还是 1 也没有阻断 我们去看看 后边 有没有一个大数 拯救我们

王东: 后边 一个数 是 4

加上 我们刚才记录的 1 和是 5 最后还是没有挑战成功 所以 最大的和 还是之前的6

王东: 现在 我带着大家 撸了一遍 整个数组

王东: 那么 这个思路 怎么实现呢?

王东: 就到了今天算法优化解 的一个核心了

王东: 我们会发现一个公式 (这个需要自己写代码 去理解和消化 光看 可能不太能理解)

王东: nums 是我们的源数组 nums[i] 就是我们的当前元素 currentMax[i] 记录 我们以i 结尾的子序列里 最大的一个子序列

那么 currentMax [i] = max(currentMax[i - 1] + nums[i], nums[i])

王东: 这个公式 大家下来去理解一下

王东: 我们一般把 这个公式 称之为 状态转移公式 我们的这种解法 称之为 动态规划解法 简称 DP

然后我们去遍历 currentMax 这个数组 里边的最大值 就是我们要找的 最大值

王东: 伪代码 我来发一下

王东: 大家稍等 手动coding....

王东: var maxSubArray = function(nums) { // 初始化源数组, 初始化An为结束的最大值 let A = nums let dp = [] let maxSum = A[0] dp[0] = A[0] for(let i = 1; i < A.length; i++){ // 状态转移公式 dp[i] = max(A[i], dp[i - 1] + A[i]) maxSum = dp[i] > maxSum ? dp[i] : maxSum } return maxSum

};

function max(a, b) { return a > b ? a : b }

王东: 然后呢 我来搞一个小的变形 (其实就是为了就能更短的代码行数解决问题, 没啥卵用)

var maxSubArray = function (nums) { let maxSum = nums[0]; let dpCurrent = nums[0]; for (let i = 1; i < nums.length; i++) { dpCurrent = Math.max(nums[i], nums[i] + dpCurrent); maxSum = Math.max(maxSum, dpCurrent); } return maxSum; };

王东: 后面发的这个解法 命比较好的超过了所有解法的耗时 (js 耗时的统计 对小数据量的测试用例下 并不准确 所以大家可以忽略=.=)

OK 到现在 我们发现了 DP的方案 可以O(n) 也就是一层循环 解决这个问题

为什么到最后我直接贴代码 没有去讲 公式 到 代码的转换呢 是为了大家用来消化 和 吸收

然后自己去实现一遍 (实现的时候 不许偷看我发的答案噢~)

慢慢的 你就会发现 算法其实也挺有意思.

解法 代表着你解决问题的思路 是否清晰

王东: 下边可以自由讨论

PS: 实在不好意思 没有准备一个类似于 视频 或者 语音的讲解 因为算法这种东西 借助 画图 和 语音 会更好理解. 下次 我跟张老师 商量一下 找更好的一个分享答案的方式.

这次就先凑活着理解

Done @张仁阳

再次谢谢大家的耐心听讲 ~

王东: @刘京 找到最大值了 只是 找的时候 记录当前的i j 就好了~ 整体思路不会变啊 只是一个求和 一个是求完和 记录坐标